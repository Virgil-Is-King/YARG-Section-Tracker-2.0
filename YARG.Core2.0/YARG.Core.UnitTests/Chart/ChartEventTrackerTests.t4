<#@ template hostspecific="false" language="C#" #>
<#@ output extension=".cs" #>
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using NUnit.Framework;
using YARG.Core.Chart;

#nullable enable

namespace YARG.Core.UnitTests.Chart;

public class ChartEventTrackerTests
{
    private List<Beatline> _events =
    [
        new(BeatlineType.Measure, 0.5 * 0, 480 * 0),
        new(BeatlineType.Strong,  0.5 * 1, 480 * 1),
        new(BeatlineType.Strong,  0.5 * 2, 480 * 2),
        new(BeatlineType.Strong,  0.5 * 3, 480 * 3),

        new(BeatlineType.Measure, 0.5 * 4, 480 * 4),
        new(BeatlineType.Strong,  0.5 * 5, 480 * 5),
        new(BeatlineType.Strong,  0.5 * 6, 480 * 6),
        new(BeatlineType.Strong,  0.5 * 7, 480 * 7),

        new(BeatlineType.Measure, 0.5 * 8,  480 * 8),
        new(BeatlineType.Strong,  0.5 * 9,  480 * 9),
        new(BeatlineType.Strong,  0.5 * 10, 480 * 10),
        new(BeatlineType.Strong,  0.5 * 11, 480 * 11),

        new(BeatlineType.Measure, 0.5 * 12, 480 * 12),
        new(BeatlineType.Strong,  0.5 * 13, 480 * 13),
        new(BeatlineType.Strong,  0.5 * 14, 480 * 14),
        new(BeatlineType.Strong,  0.5 * 15, 480 * 15),
    ];
<#
var types = new (string upper, string lower, string type, string increment)[] {
    ("Tick", "tick", "uint", "100"),
    ("Time", "time", "double", "0.1"),
};

foreach (var (upper, lower, type, increment) in types)
{
#>

    [Test]
    public void Update_<#= upper #>()
    {
        void TestUpdate(<#= type #> increment)
        {
            var tracker = new ChartEvent<#= upper #>Tracker<Beatline>(_events);

            int expectedIndex = -1;
            for (<#= type #> <#= lower #> = 0; <#= lower #> < _events[^1].<#= upper #>; <#= lower #> += increment)
            {
                // Updates must occur when reaching or exceeding the <#= lower #> of a new event
                bool updateExpected = false;
                while (expectedIndex + 1 < _events.Count && _events[expectedIndex + 1].<#= upper #> <= <#= lower #>)
                {
                    expectedIndex++;
                    updateExpected = true;
                }

                bool updated = tracker.Update(<#= lower #>);
                Assert.Multiple(() =>
                {
                    Assert.That(updated, Is.EqualTo(updateExpected));
                    Assert.That(tracker.CurrentIndex, Is.EqualTo(expectedIndex));
                    Assert.That(tracker.Current, Is.EqualTo(expectedIndex >= 0 ? _events[expectedIndex] : null));
                });

                // No more updates should occur until the next event once this update has run
                updated = tracker.Update(<#= lower #>);
                Assert.Multiple(() =>
                {
                    Assert.That(updated, Is.False);
                    Assert.That(tracker.CurrentIndex, Is.EqualTo(expectedIndex));
                    Assert.That(tracker.Current, Is.EqualTo(expectedIndex >= 0 ? _events[expectedIndex] : null));
                });
            }
        }

        TestUpdate(<#= increment #>);
        TestUpdate(<#= increment #> * 10);
    }

    [Test]
    public void UpdateOnce_<#= upper #>()
    {
        void TestUpdate(<#= type #> increment)
        {
            var tracker = new ChartEvent<#= upper #>Tracker<Beatline>(_events);

            int expectedIndex = -1;
            for (<#= type #> <#= lower #> = 0; <#= lower #> < _events[^1].<#= upper #>; <#= lower #> += increment)
            {
                Beatline? current;
                bool updated;

                // Updates must occur when reaching or exceeding the <#= lower #> of a new event
                while (expectedIndex + 1 < _events.Count && _events[expectedIndex + 1].<#= upper #> <= <#= lower #>)
                {
                    expectedIndex++;

                    updated = tracker.UpdateOnce(<#= lower #>, out current);
                    Assert.Multiple(() =>
                    {
                        Assert.That(updated, Is.True);
                        Assert.That(tracker.CurrentIndex, Is.EqualTo(expectedIndex));
                        Assert.That(tracker.Current, Is.EqualTo(_events[expectedIndex]));
                        Assert.That(current, Is.EqualTo(tracker.Current));
                    });
                }

                // No more updates should occur until the next event once all available updates are run
                updated = tracker.UpdateOnce(<#= lower #>, out current);
                Assert.Multiple(() =>
                {
                    Assert.That(updated, Is.False);
                    Assert.That(tracker.CurrentIndex, Is.EqualTo(expectedIndex));
                    Assert.That(tracker.Current, Is.EqualTo(expectedIndex >= 0 ? _events[expectedIndex] : null));
                    Assert.That(current, Is.EqualTo(tracker.Current));
                });
            }
        }

        TestUpdate(<#= increment #>);
        TestUpdate(<#= increment #> * 10);
    }

    [Test]
    public void Reset_<#= upper #>()
    {
        var tracker = new ChartEvent<#= upper #>Tracker<Beatline>(_events);

        // Update to end to ensure proper reset functionality
        bool updated = tracker.Update(_events[2].<#= upper #>);
        Assert.Multiple(() =>
        {
            Assert.That(updated, Is.True);
            Assert.That(tracker.CurrentIndex, Is.EqualTo(2));
            Assert.That(tracker.Current, Is.EqualTo(_events[2]));
        });

        // Resetting fully nullifies the current event
        tracker.Reset();
        Assert.Multiple(() =>
        {
            Assert.That(tracker.CurrentIndex, Is.EqualTo(-1));
            Assert.That(tracker.Current, Is.Null);
        });

        // Resetting to the <#= lower #> of an event should result in that event being current
        for (int i = 0; i < _events.Count; i++)
        {
            tracker.ResetTo<#= upper #>(_events[i].<#= upper #>);
            Assert.Multiple(() =>
            {
                Assert.That(tracker.CurrentIndex, Is.EqualTo(i));
                Assert.That(tracker.Current, Is.EqualTo(_events[i]));
            });
        }
    }
<#
}
#>
}